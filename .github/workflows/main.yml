# .github/workflows/docker_installer_workflow.yml # 工作流文件的建议存放路径和名称
name: Docker Installer Workflow # 工作流的名称，将显示在GitHub Actions的UI界面中

on: # 定义触发此工作流的事件
  schedule: # 定时触发器配置
    - cron: '0 16 * * *'  # CRON表达式，表示每天UTC时间16:00执行 (通常对应中国标准时间CST的次日凌晨0点)
  workflow_dispatch: {} # 允许通过GitHub Actions UI界面或API手动触发此工作流

jobs: # 定义工作流中包含的一个或多个作业
  download_and_verify: # 作业的唯一ID，此作业负责下载和验证安装程序
    runs-on: ubuntu-latest # 指定作业运行在GitHub托管的最新版Ubuntu Linux虚拟环境

    steps: # 作业中执行的一系列步骤，按顺序执行
      - name: Checkout repository # 步骤1：检出仓库代码
        uses: actions/checkout@v4 # 使用GitHub官方提供的actions/checkout@v4动作来检出当前仓库的代码到运行器环境

      - name: Set up environment # 步骤2：设置运行环境
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式: -e(错误时退出), -u(未定义变量视为错误), -f(禁用通配符), -o pipefail(管道失败则整个管道失败)
          sudo apt-get update -y # 使用sudo权限更新apt包管理器的软件包列表，-y选项表示自动确认所有提示
          sudo apt-get install -y curl # 使用sudo权限安装curl工具，用于进行HTTP请求以下载文件，-y选项自动确认

      - name: Retrieve Latest Docker Version # 步骤3：获取最新的Docker引擎稳定版本号
        id: get_latest_version # 为此步骤设置一个ID "get_latest_version"，方便后续步骤引用其输出
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          # 通过curl静默(-s)访问Docker官方下载页面，获取Linux x86_64架构的稳定版(stable)静态文件列表
          # 使用grep通过Perl兼容正则表达式(-P)和仅输出匹配部分(-o)的选项，提取所有形如 'docker-X.Y.Z' 中的版本号 'X.Y.Z'
          # (\K会忽略之前匹配到的 "docker-")
          # 使用sort -V按版本号进行自然排序（例如，2.10.0会排在2.9.0之后）
          # 使用tail -n 1取排序后的最后一行，即最新的版本号
          latest_version=$(curl -s https://download.docker.com/linux/static/stable/x86_64/ | grep -oP 'docker-\K[0-9]+\.[0-9]+\.[0-9]+' | sort -V | tail -n 1)
          if [ -z "$latest_version" ]; then # 检查获取到的latest_version变量是否为空字符串
            echo "Error: No stable Docker version found, exiting." # 如果为空，则打印错误信息
            exit 1 # 脚本以失败状态退出，这将导致此步骤失败
          fi
          echo "Latest stable Docker version: $latest_version" # 打印获取到的最新Docker引擎稳定版本号
          # 将获取到的版本号以 "version=<版本号>" 的格式追加到$GITHUB_ENV环境变量文件中
          # 这样后续步骤可以通过 ${{ env.version }} 来引用这个版本号
          echo "version=$latest_version" >>$GITHUB_ENV

      - name: Download Docker Installers # 步骤4：下载Docker Desktop安装程序
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          INSTALLER_DIR="installers" # 定义安装程序存放的目录名
          mkdir -p "$INSTALLER_DIR" # 创建该目录，-p选项表示如果父目录不存在也会一并创建，且目录已存在时不报错
          
          # 声明一个bash关联数组(associative array)名为installers，用于存储各种平台的Docker Desktop下载链接
          declare -A installers=(
            ["windows_x86_64"]="https://desktop.docker.com/win/stable/amd64/Docker%20Desktop%20Installer.exe" # Windows x86_64平台
            ["mac_arm64"]="https://desktop.docker.com/mac/stable/arm64/Docker.dmg" # Mac arm64 (Apple Silicon)平台
            ["mac_x86_64"]="https://desktop.docker.com/mac/stable/amd64/Docker.dmg" # Mac x86_64 (Intel)平台
            ["linux_debian_x86_64"]="https://desktop.docker.com/linux/main/amd64/docker-desktop-latest-amd64.deb" # Linux Debian/Ubuntu x86_64平台 (.deb)
            ["linux_fedora_x86_64"]="https://desktop.docker.com/linux/main/amd64/docker-desktop-latest-x86_64.rpm" # Linux Fedora/CentOS x86_64平台 (.rpm)
            ["linux_ubuntu_x86_64"]="https://desktop.docker.com/linux/main/amd64/docker-desktop-latest-amd64.deb" # Linux Ubuntu (与Debian使用相同的最新链接)
            ["linux_centos_x86_64"]="https://desktop.docker.com/linux/main/amd64/docker-desktop-latest-x86_64.rpm" # Linux CentOS (与Fedora使用相同的最新链接)
          )
          
          # 遍历installers关联数组的所用键(key)
          for key in "${!installers[@]}"; do
            url="${installers[$key]}" # 获取当前键对应的下载URL
            extension="${url##*.}" # 从URL中提取文件扩展名 (例如 .exe, .dmg, .deb, .rpm)
            file_name="docker_desktop_installer_${key}.${extension}" # 构建本地保存的文件名
            file_path="$INSTALLER_DIR/$file_name" # 构建本地保存的完整文件路径
            
            echo "正在从 $url 下载 $file_name" # 打印下载信息
            curl -L -o "$file_path" "$url" || { echo "错误：下载 $file_name 失败"; exit 1; }
            
            if [ ! -s "$file_path" ]; then # 检查下载后的文件是否存在且大小是否大于0 (-s)
              echo "错误：$file_name 下载失败或文件为空"
              exit 1
            fi
            echo "$file_name 下载成功."
          done

      - name: Download Docker Installation Script # 步骤5：下载Docker引擎的便捷安装脚本
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          INSTALLER_DIR="installers" # 定义安装程序存放的目录名
          mkdir -p "$INSTALLER_DIR" # 确保目录存在
          SCRIPT_URL="https://get.docker.com" # Docker引擎安装脚本的URL
          SCRIPT_FILE_NAME="docker_install.sh" # Docker引擎安装脚本的文件名
          SCRIPT_FILE_PATH="$INSTALLER_DIR/$SCRIPT_FILE_NAME" # 本地保存的完整文件路径
          echo "正在下载 Docker 安装脚本 $SCRIPT_URL 到 $SCRIPT_FILE_PATH" # 打印下载信息
          curl -sL -o "$SCRIPT_FILE_PATH" "$SCRIPT_URL" || { echo "错误：下载 $SCRIPT_FILE_NAME 失败"; exit 1; }
          echo "$SCRIPT_FILE_NAME 下载成功."

      - name: Download Docker Engine Static Binary (Linux x86_64) # 步骤6：下载Docker引擎静态二进制包
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          INSTALLER_DIR="installers" # 定义安装程序存放的目录名
          ENGINE_VERSION="${{ env.version }}" # 从 'Retrieve Latest Docker Version' 步骤获取的Docker引擎版本
          
          if [ -z "$ENGINE_VERSION" ]; then # 检查ENGINE_VERSION是否为空
            echo "错误：Docker引擎版本 (env.version) 未获取到，无法下载静态二进制包。"
            exit 1
          fi
          
          STATIC_BINARY_FILE_NAME="docker-${ENGINE_VERSION}.tgz" # 构造静态二进制包的文件名
          STATIC_BINARY_URL="https://download.docker.com/linux/static/stable/x86_64/${STATIC_BINARY_FILE_NAME}" # 构造下载URL
          
          mkdir -p "$INSTALLER_DIR" # 再次确保目录存在
          echo "正在下载 Docker 引擎静态二进制包: $STATIC_BINARY_URL" # 打印下载信息
          curl -L -o "$INSTALLER_DIR/$STATIC_BINARY_FILE_NAME" "$STATIC_BINARY_URL" || { echo "错误：下载 $STATIC_BINARY_FILE_NAME 失败"; exit 1; }
          
          if [ ! -s "$INSTALLER_DIR/$STATIC_BINARY_FILE_NAME" ]; then # 检查下载后的文件是否存在且大小是否大于0
            echo "错误：$STATIC_BINARY_FILE_NAME 下载失败或文件为空"
            exit 1
          fi
          echo "$STATIC_BINARY_FILE_NAME 下载成功到 $INSTALLER_DIR/."

      - name: Prepare Release Notes # 步骤7：准备Release的说明文档 (Release Notes)
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          generate_release_notes() { # 定义一个名为generate_release_notes的bash函数
            INSTALLER_DIR="installers" # 明确定义下载产物目录，确保函数内可用
            local release_note_file="release_notes.md" # 定义Release Notes文件名 (本地变量)
            # 获取Docker引擎版本供引用，env.version本身不带'v'
            local engine_version_from_env="${{ env.version }}" 
            local engine_version_display="v${engine_version_from_env}" # 用于显示的带'v'的版本

            # 文件计数
            local file_count # 声明局部变量
            file_count=$(find "$INSTALLER_DIR" -maxdepth 1 -type f | wc -l) # 计算installers目录中文件的数量

            # 预先收集所有文件的Markdown格式化信息块
            local file_asset_blocks_en="" # 初始化为空字符串，用于存储英文版文件信息块
            local file_asset_blocks_zh="" # 初始化为空字符串，用于存储中文版文件信息块
            local current_description="" # 用于存储当前文件的描述 (英文)

            # 使用find和while read安全遍历文件，避免globbing问题 (因set -f)
            find "$INSTALLER_DIR" -maxdepth 1 -type f -print0 | while IFS= read -r -d $'\0' file_path_in_loop; do
              local filename # 声明局部变量filename
              filename=$(basename "$file_path_in_loop") # 获取文件名
              local size # 声明局部变量size
              size=$(du -h "$file_path_in_loop" | cut -f1) # 获取人类可读的文件大小
              local modified_date # 声明局部变量modified_date
              modified_date=$(stat -c %y "$file_path_in_loop" | cut -d'.' -f1) # 获取文件的最后修改日期(UTC YY-MM-DD HH:MM:SS)
              local sha256_hash # SHA256哈希
              sha256_hash=$(sha256sum "$file_path_in_loop" | cut -d' ' -f1) # 计算SHA256校验和

              # 根据文件名生成描述 (英文)
              case "$filename" in
                "docker_install.sh")
                  current_description="Docker Engine Installation Script (Generic Linux)" ;;
                "docker-${engine_version_from_env}.tgz") # 使用不带'v'的引擎版本进行匹配
                  current_description="Docker Engine Static Binary ${engine_version_display} (Linux x86_64)" ;;
                "docker_desktop_installer_windows_x86_64.exe")
                  current_description="Docker Desktop for Windows (x86_64)" ;;
                "docker_desktop_installer_mac_arm64.dmg")
                  current_description="Docker Desktop for macOS (Apple Silicon, arm64)" ;;
                "docker_desktop_installer_mac_x86_64.dmg")
                  current_description="Docker Desktop for macOS (Intel, x86_64)" ;;
                "docker_desktop_installer_linux_debian_x86_64.deb"|\
                "docker_desktop_installer_linux_ubuntu_x86_64.deb")
                  current_description="Docker Desktop for Linux (Debian/Ubuntu based, .deb)" ;;
                "docker_desktop_installer_linux_fedora_x86_64.rpm"|\
                "docker_desktop_installer_linux_centos_x86_64.rpm")
                  current_description="Docker Desktop for Linux (Fedora/RHEL based, .rpm)" ;;
                *)
                  current_description="Utility or Installer File" ;; # 默认描述
              esac
              
              # 构建英文版文件信息块
              file_asset_blocks_en+=$(printf "#### \`%s\`\n* **Description:** %s\n* **Size:** %s\n* **SHA256:** \`%s\`\n* **Last Modified (UTC):** %s\n\n---\n" \
                                      "$filename" "$current_description" "$size" "$sha256_hash" "$modified_date")
              # 构建中文版文件信息块 (描述暂时也用英文，标签用中文)
              file_asset_blocks_zh+=$(printf "#### \`%s\`\n* **文件说明：** %s\n* **文件大小：** %s\n* **SHA256 校验和：** \`%s\`\n* **最后修改日期 (UTC)：** %s\n\n---\n" \
                                      "$filename" "$current_description" "$size" "$sha256_hash" "$modified_date")
            done

            # 使用命令组和重定向一次性生成完整的release_notes.md文件内容
            {
              # --- 1. 主标题 (双语) ---
              echo "## 🐳 Docker Installers / Docker 安装程序 - Engine ${engine_version_display} 🚀"
              echo "" 
              # --- 2. 统一的简短引言 (双语) ---
              echo "This document provides download links for various Docker installers and tools, fetched from official sources. The Docker Engine version reference above applies to the static binary and the \`get.docker.com\` script."
              echo "本文档提供了各 Docker 安装程序和工具的下载链接，均从官方源获取。上述 Docker 引擎版本号适用于静态二进制包及 \`get.docker.com\` 脚本。"
              echo ""
              echo "---" 

              # --- 3. 英文区段 ---
              echo "## 🇬🇧 English Section"
              echo ""
              echo "### Introduction" 
              echo "This release provides the latest available Docker installers and tools, fetched directly from their official sources. For enhanced security, please verify the SHA256 checksums listed below before installation. 💡" 
              echo ""
              echo "### Assets (Count: ${file_count})" # 显示文件数量
              echo "" # 空行以分隔标题和列表
              echo -e "${file_asset_blocks_en}" # 输出英文版文件信息块 (echo -e 使\n生效)
              # 末尾的---由最后一个文件的printf添加，所以此处不再需要额外的分隔线
              echo "### Notes" 
              echo "🔗 For more information, please visit the [Docker Official Documentation](https://docs.docker.com)."
              echo "🙌 Thank you for using Docker!"
              echo ""
              echo "---" 

              # --- 4. 中文区段 ---
              echo "## 🇨🇳 中文说明"
              echo ""
              echo "### 简介" 
              echo "此版本提供了从官方来源获取的最新可用 Docker 安装程序和工具。为增强安全性，请在安装前校验下方列出的 SHA256 校验和。💡" 
              echo ""
              echo "### 资产文件 (数量: ${file_count})" # 显示文件数量
              echo "" # 空行以分隔标题和列表
              echo -e "${file_asset_blocks_zh}" # 输出中文版文件信息块
              # 末尾的---由最后一个文件的printf添加
              echo "### 备注" 
              echo "🔗 获取更多信息，请访问 [Docker 官方文档](https://docs.docker.com)。"
              echo "🙌 感谢您使用 Docker！"
            } > "$release_note_file" # 将以上所有echo的输出重定向到release_note_file文件

            echo "--- Generated Release Notes (Content below will be in the GitHub Release) ---" 
            cat "$release_note_file" 
            echo "--- End of Release Notes ---" 
          }
          generate_release_notes # 调用定义的bash函数来实际生成Release Notes

      - name: Create Release # 步骤8：创建GitHub Release
        id: release # 为此步骤设置ID "release"
        uses: softprops/action-gh-release@v2 # 使用softprops/action-gh-release@v2动作来创建Release
        with: # 配置参数
          tag_name: "latest" # Release的标签名，设置为静态的 "latest" (会覆盖同名旧标签)
          name: "Docker Installers - Latest Available (Engine v${{ env.version }})" # Release的名称
          body_path: release_notes.md # Release的说明内容从 "release_notes.md" 文件读取
          # 列出要附加到Release的资产文件 (assets)
          files: | # 多行字符串，每行一个文件路径
            installers/docker_install.sh
            installers/docker-${{ env.version }}.tgz
            installers/docker_desktop_installer_windows_x86_64.exe
            installers/docker_desktop_installer_mac_arm64.dmg
            installers/docker_desktop_installer_mac_x86_64.dmg
            installers/docker_desktop_installer_linux_debian_x86_64.deb
            installers/docker_desktop_installer_linux_fedora_x86_64.rpm
            installers/docker_desktop_installer_linux_ubuntu_x86_64.deb
            installers/docker_desktop_installer_linux_centos_x86_64.rpm
        env: # 设置此步骤的环境变量
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # 传入GITHUB_TOKEN，用于授权action创建Release

      - name: Output Release Notes # 步骤9：再次输出Release Notes (可选，用于确认)
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          echo "Final Release Notes Content (from file):"
          if [ -f "release_notes.md" ]; then # 检查文件是否存在
             cat "release_notes.md" # 在Runner的控制台打印最终的Release Notes内容
          else
             echo "Warning: release_notes.md not found." # 如果文件不存在，则打印警告
          fi
        continue-on-error: true # 即使此步骤失败，也继续执行工作流（虽然是最后的可执行用户步骤）
