
计划已制定完毕。我将直接进入 EXECUTE 模式提供修复后的完整代码。

`[MODE: EXECUTE]`

我将开始执行已批准的计划，直接生成包含所有修改的完整工作流文件。
由于用户请求直接生成最终代码，我将合并所有清单步骤的执行，并一次性提供最终结果。
所有标记为 `review:true` 的步骤都将被执行。标记为 `review:false` 的次要调整（如子标题 ICON）将不被包含，除非它们是实现核心需求所必需的。

**执行摘要**:
1.  **ICON 映射逻辑**: 将在 `case "$filename"` 中添加 `file_icon` 的设置。
2.  **`printf` 修改**: 完全替换旧的 `printf`，使用新的 HTML `<details>` 结构。
3.  **旧分隔线移除**: 新的 `printf` 将不包含 `---`，而是使用 `<br>`。

```yaml
# .github/workflows/docker_installer_workflow.yml
name: Docker Installer Workflow # 工作流的名称，将显示在GitHub Actions的UI界面中

on: # 定义触发此工作流的事件
  schedule: # 定时触发器配置
    - cron: '0 16 * * *'  # CRON表达式，表示每天UTC时间16:00执行 (通常对应中国标准时间CST的次日凌晨0点)
  workflow_dispatch: {} # 允许通过GitHub Actions UI界面或API手动触发此工作流

jobs: # 定义工作流中包含的一个或多个作业
  download_and_verify: # 作业的唯一ID，此作业负责下载和验证安装程序
    runs-on: ubuntu-latest # 指定作业运行在GitHub托管的最新版Ubuntu Linux虚拟环境

    steps: # 作业中执行的一系列步骤，按顺序执行
      - name: Checkout repository # 步骤1：检出仓库代码
        uses: actions/checkout@v4 # 使用GitHub官方提供的actions/checkout@v4动作来检出当前仓库的代码到运行器环境

      - name: Set up environment # 步骤2：设置运行环境
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式: -e(错误时退出), -u(未定义变量视为错误), -f(禁用通配符), -o pipefail(管道失败则整个管道失败)
          sudo apt-get update -y # 使用sudo权限更新apt包管理器的软件包列表，-y选项表示自动确认所有提示
          sudo apt-get install -y curl # 使用sudo权限安装curl工具，用于进行HTTP请求以下载文件，-y选项自动确认

      - name: Retrieve Latest Docker Version # 步骤3：获取最新的Docker引擎稳定版本号
        id: get_latest_version # 为此步骤设置一个ID "get_latest_version"，方便后续步骤引用其输出
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          latest_version=$(curl -s https://download.docker.com/linux/static/stable/x86_64/ | grep -oP 'docker-\K[0-9]+\.[0-9]+\.[0-9]+' | sort -V | tail -n 1)
          if [ -z "$latest_version" ]; then # 检查获取到的latest_version变量是否为空字符串
            echo "Error: No stable Docker version found, exiting." # 如果为空，则打印错误信息
            exit 1 # 脚本以失败状态退出，这将导致此步骤失败
          fi
          echo "Latest stable Docker version: $latest_version" # 打印获取到的最新Docker引擎稳定版本号
          echo "version=$latest_version" >>$GITHUB_ENV

      - name: Download Docker Installers # 步骤4：下载Docker Desktop安装程序
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          INSTALLER_DIR="installers" # 定义安装程序存放的目录名
          mkdir -p "$INSTALLER_DIR" # 创建该目录，-p选项表示如果父目录不存在也会一并创建，且目录已存在时不报错
          
          declare -A installers=(
            ["windows_x86_64"]="https://desktop.docker.com/win/stable/amd64/Docker%20Desktop%20Installer.exe"
            ["mac_arm64"]="https://desktop.docker.com/mac/stable/arm64/Docker.dmg"
            ["mac_x86_64"]="https://desktop.docker.com/mac/stable/amd64/Docker.dmg"
            ["linux_debian_x86_64"]="https://desktop.docker.com/linux/main/amd64/docker-desktop-latest-amd64.deb"
            ["linux_fedora_x86_64"]="https://desktop.docker.com/linux/main/amd64/docker-desktop-latest-x86_64.rpm"
            ["linux_ubuntu_x86_64"]="https://desktop.docker.com/linux/main/amd64/docker-desktop-latest-amd64.deb" # 与Debian使用相同的最新链接
            ["linux_centos_x86_64"]="https://desktop.docker.com/linux/main/amd64/docker-desktop-latest-x86_64.rpm" # 与Fedora使用相同的最新链接
          )
          
          for key in "${!installers[@]}"; do
            url="${installers[$key]}"
            extension="${url##*.}"
            file_name="docker_desktop_installer_${key}.${extension}"
            file_path="$INSTALLER_DIR/$file_name"
            
            echo "正在从 $url 下载 $file_name"
            curl -L -o "$file_path" "$url" || { echo "错误：下载 $file_name 失败"; exit 1; }
            
            if [ ! -s "$file_path" ]; then
              echo "错误：$file_name 下载失败或文件为空"
              exit 1
            fi
            echo "$file_name 下载成功."
          done

      - name: Download Docker Installation Script # 步骤5：下载Docker引擎的便捷安装脚本
        run: |
          set -euf -o pipefail
          INSTALLER_DIR="installers"
          mkdir -p "$INSTALLER_DIR"
          SCRIPT_URL="https://get.docker.com"
          SCRIPT_FILE_NAME="docker_install.sh"
          SCRIPT_FILE_PATH="$INSTALLER_DIR/$SCRIPT_FILE_NAME"
          echo "正在下载 Docker 安装脚本 $SCRIPT_URL 到 $SCRIPT_FILE_PATH"
          curl -sL -o "$SCRIPT_FILE_PATH" "$SCRIPT_URL" || { echo "错误：下载 $SCRIPT_FILE_NAME 失败"; exit 1; }
          echo "$SCRIPT_FILE_NAME 下载成功."

      - name: Download Docker Engine Static Binary (Linux x86_64) # 步骤6：下载Docker引擎静态二进制包
        run: |
          set -euf -o pipefail
          INSTALLER_DIR="installers"
          ENGINE_VERSION="${{ env.version }}"
          
          if [ -z "$ENGINE_VERSION" ]; then
            echo "错误：Docker引擎版本 (env.version) 未获取到，无法下载静态二进制包。"
            exit 1
          fi
          
          STATIC_BINARY_FILE_NAME="docker-${ENGINE_VERSION}.tgz"
          STATIC_BINARY_URL="https://download.docker.com/linux/static/stable/x86_64/${STATIC_BINARY_FILE_NAME}"
          
          mkdir -p "$INSTALLER_DIR"
          echo "正在下载 Docker 引擎静态二进制包: $STATIC_BINARY_URL"
          curl -L -o "$INSTALLER_DIR/$STATIC_BINARY_FILE_NAME" "$STATIC_BINARY_URL" || { echo "错误：下载 $STATIC_BINARY_FILE_NAME 失败"; exit 1; }
          
          if [ ! -s "$INSTALLER_DIR/$STATIC_BINARY_FILE_NAME" ]; then
            echo "错误：$STATIC_BINARY_FILE_NAME 下载失败或文件为空"
            exit 1
          fi
          echo "$STATIC_BINARY_FILE_NAME 下载成功到 $INSTALLER_DIR/."

      - name: Prepare Release Notes # 步骤7：准备Release的说明文档 (Release Notes)
        run: |
          set -euf -o pipefail
          generate_release_notes() {
            INSTALLER_DIR="installers"
            local release_note_file="release_notes.md"
            local engine_version_from_env="${{ env.version }}" 
            local engine_version_display="v${engine_version_from_env}"

            local file_count
            file_count=$(find "$INSTALLER_DIR" -maxdepth 1 -type f -print0 | wc -l)

            local file_asset_blocks_en=""
            local file_asset_blocks_zh=""
            local current_description="" # 英文描述
            # 中文描述可以考虑翻译或保持英文，此处为简化，中文描述也用current_description
            # local current_description_zh="" 

            # 使用进程替换来确保while循环在当前shell上下文中运行 (已在上一轮修复)
            while IFS= read -r -d $'\0' file_path_in_loop; do
              local filename
              filename=$(basename "$file_path_in_loop")
              local size
              size=$(du -h "$file_path_in_loop" | cut -f1)
              local modified_date
              modified_date=$(stat -c %y "$file_path_in_loop" | cut -d'.' -f1)
              local sha256_hash
              sha256_hash=$(sha256sum "$file_path_in_loop" | cut -d' ' -f1)
              
              local file_icon="📦" # Default ICON

              case "$filename" in
                "docker_install.sh")
                  current_description="Docker Engine Installation Script (Generic Linux)"
                  # current_description_zh="Docker 引擎安装脚本 (通用 Linux)"
                  file_icon="📜" ;;
                "docker-${engine_version_from_env}.tgz")
                  current_description="Docker Engine Static Binary ${engine_version_display} (Linux x86_64)"
                  # current_description_zh="Docker 引擎静态二进制文件 ${engine_version_display} (Linux x86_64)"
                  file_icon="🐧" ;;
                "docker_desktop_installer_windows_x86_64.exe")
                  current_description="Docker Desktop for Windows (x86_64)"
                  # current_description_zh="Docker Desktop Windows 版 (x86_64)"
                  file_icon="🪟" ;;
                "docker_desktop_installer_mac_arm64.dmg")
                  current_description="Docker Desktop for macOS (Apple Silicon, arm64)"
                  # current_description_zh="Docker Desktop macOS 版 (Apple Silicon, arm64)"
                  file_icon="🍏" ;;
                "docker_desktop_installer_mac_x86_64.dmg")
                  current_description="Docker Desktop for macOS (Intel, x86_64)"
                  # current_description_zh="Docker Desktop macOS 版 (Intel, x86_64)"
                  file_icon="🍏" ;;
                "docker_desktop_installer_linux_debian_x86_64.deb"|\
                "docker_desktop_installer_linux_ubuntu_x86_64.deb")
                  current_description="Docker Desktop for Linux (Debian/Ubuntu based, .deb)"
                  # current_description_zh="Docker Desktop Linux 版 (基于 Debian/Ubuntu, .deb)"
                  file_icon="🐧" ;;
                "docker_desktop_installer_linux_fedora_x86_64.rpm"|\
                "docker_desktop_installer_linux_centos_x86_64.rpm")
                  current_description="Docker Desktop for Linux (Fedora/RHEL based, .rpm)"
                  # current_description_zh="Docker Desktop Linux 版 (基于 Fedora/RHEL, .rpm)"
                  file_icon="🐧" ;;
                *)
                  current_description="Utility or Installer File"
                  # current_description_zh="实用工具或安装文件"
                  file_icon="📦" ;;
              esac
              
              # 构建英文版文件信息块 (HTML <details> 格式)
              file_asset_blocks_en+=$(printf "<details>\n  <summary><strong>%s <code>%s</code></strong></summary>\n  <ul style=\"list-style-type: none; padding-left: 20px; margin-top: 5px;\">\n    <li><strong>Description:</strong> %s</li>\n    <li><strong>Size:</strong> %s</li>\n    <li><strong>SHA256:</strong> <code>%s</code></li>\n    <li><strong>Last Modified (UTC):</strong> %s</li>\n  </ul>\n</details>\n<br>\n" \
                                      "$file_icon" "$filename" "$current_description" "$size" "$sha256_hash" "$modified_date")
              
              # 构建中文版文件信息块 (HTML <details> 格式)
              # 如果有 current_description_zh, 则使用它，否则沿用 current_description
              local effective_description_zh="$current_description" # 默认为英文描述
              # if [ -n "$current_description_zh" ]; then effective_description_zh="$current_description_zh"; fi # 如果需要独立中文描述则取消注释此行和case中的赋值

              file_asset_blocks_zh+=$(printf "<details>\n  <summary><strong>%s <code>%s</code></strong></summary>\n  <ul style=\"list-style-type: none; padding-left: 20px; margin-top: 5px;\">\n    <li><strong>文件说明：</strong> %s</li>\n    <li><strong>文件大小：</strong> %s</li>\n    <li><strong>SHA256 校验和：</strong> <code>%s</code></li>\n    <li><strong>最后修改日期 (UTC)：</strong> %s</li>\n  </ul>\n</details>\n<br>\n" \
                                      "$file_icon" "$filename" "$effective_description_zh" "$size" "$sha256_hash" "$modified_date")
            done < <(find "$INSTALLER_DIR" -maxdepth 1 -type f -print0)

            {
              echo "## 🐳 Docker Installers / Docker 安装程序 - Engine ${engine_version_display} 🚀"
              echo "" 
              echo "This document provides download links for various Docker installers and tools, fetched from official sources. The Docker Engine version reference above applies to the static binary and the \`get.docker.com\` script."
              echo "本文档提供了各 Docker 安装程序和工具的下载链接，均从官方源获取。上述 Docker 引擎版本号适用于静态二进制包及 \`get.docker.com\` 脚本。"
              echo ""
              echo "---" 
              echo "## 🇬🇧 English Section"
              echo ""
              echo "### Introduction" 
              echo "This release provides the latest available Docker installers and tools, fetched directly from their official sources. For enhanced security, please verify the SHA256 checksums listed below before installation. 💡" 
              echo ""
              echo "### <samp>🗂️</samp> Assets (Count: ${file_count})" # 子标题ICON (可选)
              echo ""
              echo -e "${file_asset_blocks_en}"
              echo "### Notes" 
              echo "🔗 For more information, please visit the [Docker Official Documentation](https://docs.docker.com)."
              echo "🙌 Thank you for using Docker!"
              echo ""
              echo "---" 
              echo "## 🇨🇳 中文说明"
              echo ""
              echo "### 简介" 
              echo "此版本提供了从官方来源获取的最新可用 Docker 安装程序和工具。为增强安全性，请在安装前校验下方列出的 SHA256 校验和。💡" 
              echo ""
              echo "### <samp>🗂️</samp> 资产文件 (数量: ${file_count})" # 子标题ICON (可选)
              echo ""
              echo -e "${file_asset_blocks_zh}"
              echo "### 备注" 
              echo "🔗 获取更多信息，请访问 [Docker 官方文档](https://docs.docker.com)。"
              echo "🙌 感谢您使用 Docker！"
            } > "$release_note_file"

            echo "--- Generated Release Notes (Content below will be in the GitHub Release) ---" 
            cat "$release_note_file" 
            echo "--- End of Release Notes ---" 
          }
          generate_release_notes

      - name: Create Release
        id: release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "latest"
          name: "Docker Installers - Latest Available (Engine v${{ env.version }})"
          body_path: release_notes.md
          files: |
            installers/docker_install.sh
            installers/docker-${{ env.version }}.tgz
            installers/docker_desktop_installer_windows_x86_64.exe
            installers/docker_desktop_installer_mac_arm64.dmg
            installers/docker_desktop_installer_mac_x86_64.dmg
            installers/docker_desktop_installer_linux_debian_x86_64.deb
            installers/docker_desktop_installer_linux_fedora_x86_64.rpm
            installers/docker_desktop_installer_linux_ubuntu_x86_64.deb # 同上
            installers/docker_desktop_installer_linux_centos_x86_64.rpm # 同上
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Output Release Notes
        run: |
          set -euf -o pipefail
          echo "Final Release Notes Content (from file):"
          if [ -f "release_notes.md" ]; then
             cat "release_notes.md"
          else
             echo "Warning: release_notes.md not found."
          fi
        continue-on-error: true
