# .github/workflows/docker_installer_workflow.yml # 工作流文件的建议存放路径和名称
name: Docker Installer Workflow # 工作流的名称，将显示在GitHub Actions的UI界面中

on: # 定义触发此工作流的事件
  schedule: # 定时触发器配置
    - cron: '0 16 * * *'  # CRON表达式，表示每天UTC时间16:00执行 (通常对应中国标准时间CST的次日凌晨0点)
  workflow_dispatch: {} # 允许通过GitHub Actions UI界面或API手动触发此工作流

jobs: # 定义工作流中包含的一个或多个作业
  download_and_verify: # 作业的唯一ID，此作业负责下载和验证安装程序
    runs-on: ubuntu-latest # 指定作业运行在GitHub托管的最新版Ubuntu Linux虚拟环境

    steps: # 作业中执行的一系列步骤，按顺序执行
      - name: Checkout repository # 步骤1：检出仓库代码
        uses: actions/checkout@v4 # 使用GitHub官方提供的actions/checkout@v4动作来检出当前仓库的代码到运行器环境

      - name: Set up environment # 步骤2：设置运行环境
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式: -e(错误时退出), -u(未定义变量视为错误), -f(禁用通配符), -o pipefail(管道失败则整个管道失败)
          sudo apt-get update -y # 使用sudo权限更新apt包管理器的软件包列表，-y选项表示自动确认所有提示
          sudo apt-get install -y curl # 使用sudo权限安装curl工具，用于进行HTTP请求以下载文件，-y选项自动确认

      - name: Retrieve Latest Docker Version # 步骤3：获取最新的Docker引擎稳定版本号
        id: get_latest_version # 为此步骤设置一个ID "get_latest_version"，方便后续步骤引用其输出
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          # 通过curl静默(-s)访问Docker官方下载页面，获取Linux x86_64架构的稳定版(stable)静态文件列表
          # 使用grep通过Perl兼容正则表达式(-P)和仅输出匹配部分(-o)的选项，提取所有形如 'docker-X.Y.Z' 中的版本号 'X.Y.Z'
          # (\K会忽略之前匹配到的 "docker-")
          # 使用sort -V按版本号进行自然排序（例如，2.10.0会排在2.9.0之后）
          # 使用tail -n 1取排序后的最后一行，即最新的版本号
          latest_version=$(curl -s https://download.docker.com/linux/static/stable/x86_64/ | grep -oP 'docker-\K[0-9]+\.[0-9]+\.[0-9]+' | sort -V | tail -n 1)
          if [ -z "$latest_version" ]; then # 检查获取到的latest_version变量是否为空字符串
            echo "Error: No stable Docker version found, exiting." # 如果为空，则打印错误信息
            exit 1 # 脚本以失败状态退出，这将导致此步骤失败
          fi
          echo "Latest stable Docker version: $latest_version" # 打印获取到的最新Docker引擎稳定版本号
          # 将获取到的版本号以 "version=<版本号>" 的格式追加到$GITHUB_ENV环境变量文件中
          # 这样后续步骤可以通过 ${{ env.version }} 来引用这个版本号
          echo "version=$latest_version" >>$GITHUB_ENV

      - name: Download Docker Installers # 步骤4：下载Docker Desktop安装程序
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          INSTALLER_DIR="installers" # 定义安装程序存放的目录名
          mkdir -p "$INSTALLER_DIR" # 创建该目录，-p选项表示如果父目录不存在也会一并创建，且目录已存在时不报错
          
          # 声明一个bash关联数组(associative array)名为installers，用于存储各种平台的Docker Desktop下载链接
          declare -A installers=(
            ["windows_x86_64"]="https://desktop.docker.com/win/stable/amd64/Docker%20Desktop%20Installer.exe" # Windows x86_64平台
            ["mac_arm64"]="https://desktop.docker.com/mac/stable/arm64/Docker.dmg" # Mac arm64 (Apple Silicon)平台
            ["mac_x86_64"]="https://desktop.docker.com/mac/stable/amd64/Docker.dmg" # Mac x86_64 (Intel)平台
            ["linux_debian_x86_64"]="https://desktop.docker.com/linux/main/amd64/docker-desktop-latest-amd64.deb" # Linux Debian/Ubuntu x86_64平台 (.deb)
            ["linux_fedora_x86_64"]="https://desktop.docker.com/linux/main/amd64/docker-desktop-latest-x86_64.rpm" # Linux Fedora/CentOS x86_64平台 (.rpm)
            ["linux_ubuntu_x86_64"]="https://desktop.docker.com/linux/main/amd64/docker-desktop-latest-amd64.deb" # Linux Ubuntu (与Debian使用相同的最新链接)
            ["linux_centos_x86_64"]="https://desktop.docker.com/linux/main/amd64/docker-desktop-latest-x86_64.rpm" # Linux CentOS (与Fedora使用相同的最新链接)
          )
          
          # 遍历installers关联数组的所用键(key)
          for key in "${!installers[@]}"; do
            url="${installers[$key]}" # 获取当前键对应的下载URL
            extension="${url##*.}" # 从URL中提取文件扩展名 (例如 .exe, .dmg, .deb, .rpm)
            file_name="docker_desktop_installer_${key}.${extension}" # 构建本地保存的文件名
            file_path="$INSTALLER_DIR/$file_name" # 构建本地保存的完整文件路径
            
            echo "正在从 $url 下载 $file_name" # 打印下载信息
            curl -L -o "$file_path" "$url" || { echo "错误：下载 $file_name 失败"; exit 1; }
            
            if [ ! -s "$file_path" ]; then # 检查下载后的文件是否存在且大小是否大于0 (-s)
              echo "错误：$file_name 下载失败或文件为空"
              exit 1
            fi
            echo "$file_name 下载成功."
          done

      - name: Download Docker Installation Script # 步骤5：下载Docker引擎的便捷安装脚本
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          INSTALLER_DIR="installers" # 定义安装程序存放的目录名
          mkdir -p "$INSTALLER_DIR" # 确保目录存在
          SCRIPT_URL="https://get.docker.com" # Docker引擎安装脚本的URL
          SCRIPT_FILE_NAME="docker_install.sh" # Docker引擎安装脚本的文件名
          SCRIPT_FILE_PATH="$INSTALLER_DIR/$SCRIPT_FILE_NAME" # 本地保存的完整文件路径
          echo "正在下载 Docker 安装脚本 $SCRIPT_URL 到 $SCRIPT_FILE_PATH" # 打印下载信息
          curl -sL -o "$SCRIPT_FILE_PATH" "$SCRIPT_URL" || { echo "错误：下载 $SCRIPT_FILE_NAME 失败"; exit 1; }
          echo "$SCRIPT_FILE_NAME 下载成功."

      - name: Download Docker Engine Static Binary (Linux x86_64) # 步骤6：下载Docker引擎静态二进制包
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          INSTALLER_DIR="installers" # 定义安装程序存放的目录名
          ENGINE_VERSION="${{ env.version }}" # 从 'Retrieve Latest Docker Version' 步骤获取的Docker引擎版本
          
          if [ -z "$ENGINE_VERSION" ]; then # 检查ENGINE_VERSION是否为空
            echo "错误：Docker引擎版本 (env.version) 未获取到，无法下载静态二进制包。"
            exit 1
          fi
          
          STATIC_BINARY_FILE_NAME="docker-${ENGINE_VERSION}.tgz" # 构造静态二进制包的文件名
          STATIC_BINARY_URL="https://download.docker.com/linux/static/stable/x86_64/${STATIC_BINARY_FILE_NAME}" # 构造下载URL
          
          mkdir -p "$INSTALLER_DIR" # 再次确保目录存在
          echo "正在下载 Docker 引擎静态二进制包: $STATIC_BINARY_URL" # 打印下载信息
          curl -L -o "$INSTALLER_DIR/$STATIC_BINARY_FILE_NAME" "$STATIC_BINARY_URL" || { echo "错误：下载 $STATIC_BINARY_FILE_NAME 失败"; exit 1; }
          
          if [ ! -s "$INSTALLER_DIR/$STATIC_BINARY_FILE_NAME" ]; then # 检查下载后的文件是否存在且大小是否大于0
            echo "错误：$STATIC_BINARY_FILE_NAME 下载失败或文件为空"
            exit 1
          fi
          echo "$STATIC_BINARY_FILE_NAME 下载成功到 $INSTALLER_DIR/."

      - name: Prepare Release Notes # 步骤7：准备Release的说明文档 (Release Notes)
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          generate_release_notes() { # 定义一个名为generate_release_notes的bash函数
            INSTALLER_DIR="installers" # 明确定义下载产物目录，确保函数内可用
            local release_note_file="release_notes.md" # 定义Release Notes文件名 (本地变量)
            local engine_version_ref="v${{ env.version }}" # 获取Docker引擎版本供引用

            # 预先收集所有文件的Markdown表格行数据
            local file_data_rows="" # 初始化为空字符串
            for file in "$INSTALLER_DIR"/*; do # 遍历installers目录下的所有条目
              if [ -f "$file" ]; then # 检查是否为普通文件 (排除目录等)
                local filename # 声明局部变量filename
                filename=$(basename "$file") # 获取文件名
                local size # 声明局部变量size
                size=$(du -h "$file" | cut -f1) # 获取人类可读的文件大小
                local modified_date # 声明局部变量modified_date
                modified_date=$(stat -c %y "$file" | cut -d'.' -f1) # 获取文件的最后修改日期(UTC YYYY-MM-DD HH:MM:SS)
                # 将格式化后的Markdown表格行追加到变量，注意使用printf确保\n被正确处理为换行符
                file_data_rows=$(printf "%s| \`%s\` | %s | %s |\n" "$file_data_rows" "$filename" "$size" "$modified_date")
              fi
            done

            # 使用命令组和重定向一次性生成完整的release_notes.md文件内容
            {
              # --- 1. 主标题 (双语) ---
              echo "## 🐳 Docker Installers / Docker 安装程序 - Engine ${engine_version_ref} 🚀"
              echo "" # 空行用于Markdown渲染间距
              # --- 2. 统一的简短引言 (双语) ---
              echo "This document provides download links for various Docker installers and tools, fetched from official sources. The Docker Engine version reference above applies to the static binary and the \`get.docker.com\` script."
              echo "本文档提供了各 Docker 安装程序和工具的下载链接，均从官方源获取。上述 Docker 引擎版本号适用于静态二进制包及 \`get.docker.com\` 脚本。"
              echo ""
              echo "---" # Markdown水平分割线

              # --- 3. 英文区段 ---
              echo "## 🇬🇧 English Section"
              echo ""
              echo "### Introduction" # 英文区段小标题
              echo "This release provides the latest available Docker installers and tools, fetched directly from their official sources. Please verify checksums (if available from source) before installation for maximum security. 💡"
              echo ""
              echo "### Downloads" # 英文下载列表小标题
              echo "| File Name | Size | Last Modified (UTC) |" # 英文表格头
              echo "|:----------|:-----|:--------------------|" # 英文表格对齐控制
              echo -e "$file_data_rows" # 输出之前收集并格式化好的文件数据行 (echo -e 使\n生效)
              echo ""
              echo "### Notes" # 英文备注小标题
              echo "🔗 For more information, please visit the [Docker Official Documentation](https://docs.docker.com)."
              echo "🙌 Thank you for using Docker!"
              echo ""
              echo "---" # Markdown水平分割线

              # --- 4. 中文区段 ---
              echo "## 🇨🇳 中文说明"
              echo ""
              echo "### 简介" # 中文区段小标题
              echo "此版本提供了从官方来源获取的最新可用 Docker 安装程序和工具。为确保最大程度的安全，请在安装前校验文件的校验和（如果官方源提供）。💡"
              echo ""
              echo "### 下载列表" # 中文下载列表小标题
              echo "| 文件名      | 文件大小 | 最后修改日期 (UTC)    |" # 中文表格头
              echo "|:----------|:-------|:-----------------------:|" # 中文表格对齐控制 (可根据实际内容调整)
              echo -e "$file_data_rows" # 再次输出文件数据行
              echo ""
              echo "### 备注" # 中文备注小标题
              echo "🔗 获取更多信息，请访问 [Docker 官方文档](https://docs.docker.com)。"
              echo "🙌 感谢您使用 Docker！"
            } > "$release_note_file" # 将以上所有echo的输出重定向到release_note_file文件

            echo "--- Generated Release Notes (Content below will be in the GitHub Release) ---" # 控制台输出标记
            cat "$release_note_file" # 在Runner的控制台打印生成的Release Notes内容，用于调试或记录
            echo "--- End of Release Notes ---" # 控制台输出标记
          }
          generate_release_notes # 调用定义的bash函数来实际生成Release Notes

      - name: Create Release # 步骤8：创建GitHub Release
        id: release # 为此步骤设置ID "release"
        uses: softprops/action-gh-release@v2 # 使用softprops/action-gh-release@v2动作来创建Release
        with: # 配置参数
          tag_name: "latest" # Release的标签名，设置为静态的 "latest" (会覆盖同名旧标签)
          name: "Docker Installers - Latest Available (Engine v${{ env.version }})" # Release的名称
          body_path: release_notes.md # Release的说明内容从 "release_notes.md" 文件读取
          # 列出要附加到Release的资产文件 (assets)
          files: | # 多行字符串，每行一个文件路径
            installers/docker_install.sh
            installers/docker-${{ env.version }}.tgz
            installers/docker_desktop_installer_windows_x86_64.exe
            installers/docker_desktop_installer_mac_arm64.dmg
            installers/docker_desktop_installer_mac_x86_64.dmg
            installers/docker_desktop_installer_linux_debian_x86_64.deb
            installers/docker_desktop_installer_linux_fedora_x86_64.rpm
            installers/docker_desktop_installer_linux_ubuntu_x86_64.deb
            installers/docker_desktop_installer_linux_centos_x86_64.rpm
        env: # 设置此步骤的环境变量
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # 传入GITHUB_TOKEN，用于授权action创建Release

      - name: Output Release Notes # 步骤9：再次输出Release Notes (可选，用于确认)
        run: | # 执行多行shell命令
          set -euf -o pipefail # 设置bash脚本的严格模式
          echo "Final Release Notes Content (from file):"
          if [ -f "release_notes.md" ]; then # 检查文件是否存在
             cat "release_notes.md" # 在Runner的控制台打印最终的Release Notes内容
          else
             echo "Warning: release_notes.md not found." # 如果文件不存在，则打印警告
          fi
        continue-on-error: true # 即使此步骤失败，也继续执行工作流（虽然是最后的可执行用户步骤）
